#!cubit
reset

#import stl "/home/user/cubit/3d_print/Ork_Veteran.stl" feature_angle 135.00 merge 
#import stl "/home/user/cubit/3d_print/Minotaur.stl" feature_angle 135.00 merge
#import stl "/home/user/cubit/3d_print/Skull_Rose_-_Paintbrush_Holder-Serev3D.stl" feature_angle 135.00 merge
#import stl "/home/user/cubit/3d_print/goku_w_base.stl" feature_angle 135.00 merge
#import acis "/home/user/cubit/3d_print/knuckle.sat" nofreesurfaces heal attributes_on  separate_bodies 
#Volume 1  rotate 90 about x 

create frustum height 80 radius 20 top 0
move volume 1 z -20
Volume 1  copy rotate 180 about x 
unite volume 1 2 
compress

#!python
layers = 50
mesh_size = 2

# volume id for imported stl
vid = 1

# bounding box volume ids and blocks
cube_vids = []

vector_list = cubit.get_bounding_box("volume" , vid)
cubit.cmd(f"move volume {vid} x {-vector_list[0]} y {-vector_list[3]} z {-vector_list[6]}")
cubit.cmd(f"view bottom")

# from https://forum.coreform.com/t/python-showcase-find-hexes-whose-centroids-are-inside-a-body/1265
import time

def list_to_str(input_val):
  return " ".join([str(val) for val in input_val])

def boundary_cube(volume_id,size,number_of_layers):
  #cubit.cmd(f"create brick bounding box Volume {volume_id} tight")
  bb_list = cubit.get_bounding_box("volume" , volume_id)
  cubit.cmd(f"create brick x {bb_list[2]} y {bb_list[5]} z {bb_list[8]}")
  cubit.cmd(f"move volume {cubit.get_last_id('volume')} x {bb_list[2]/2} y {bb_list[5]/2} z {bb_list[8]/2}")
  #cut into layers
  bb_vid =  cubit.get_last_id('volume')
  for i in range(number_of_layers):
   if i!=0:
    cubit.cmd(f"webcut volume {bb_vid} with plane zplane offset {bb_list[8]/(number_of_layers)*i}")
    cube_vids.append(cubit.get_last_id('volume'))
   if i==number_of_layers-1:
    cube_vids.append(bb_vid)
  #cubit.cmd(f"merge vol {' '.join(str(id) for id in cube_vids)}")

  for i in range(len(cube_vids)):
   cubit.cmd(f"Volume {cube_vids[i]} size {size}")
   cubit.cmd(f"mesh Volume {cube_vids[i]}")
   #if refine_level > 0:
   #  cubit.cmd(f'refine hex all numsplit {refine_level} bias 1.0 depth 1 ')
  #cubit.cmd("compress")

def create_nodal_coordinates_array():
  nCoord = []
  node_ids = cubit.get_entities("node")
  for id in node_ids:
    nCoord.append(cubit.get_nodal_coordinates(id))
  return nCoord

def get_hex_centroid(hex_id, global_node_coords):
  hex_nodes = cubit.get_connectivity("hex", hex_id)
  cx=cy=cz=0
  count = 0
  for node_id in hex_nodes:
    cx += global_node_coords[node_id-1][0]
    cy += global_node_coords[node_id-1][1]
    cz += global_node_coords[node_id-1][2]
    count += 1
  cx = cx/count
  cy = cy/count
  cz = cz/count
  return cx, cy, cz

def vol_hexes_in_body(source_volume_id, target_body_id, block_id):
  BODY = cubit.body(target_body_id)
  vol_hexes = cubit.get_volume_hexes(source_volume_id)
  block_hexes = []
  nCoord = create_nodal_coordinates_array()
  for hex_id in vol_hexes:
    cx, cy, cz = get_hex_centroid(hex_id, nCoord)   
    if BODY.point_containment([cx, cy, cz]):
      block_hexes.append(hex_id)
  if len(block_hexes)>0:
   cubit.silent_cmd(f"block {block_id} hex {list_to_str(block_hexes)}")

def create_vol_from_hexes():
  block_ids = cubit.parse_cubit_list("block","all")
  for bid in block_ids:
   t0 = time.perf_counter()
   block_hexes = cubit.parse_cubit_list("hex",f"all in block {bid}")
   for i in range(len(block_hexes)):
    cubit.silent_cmd(f"create brick bounding box hex {block_hexes[i]} tight")
    new_vid = cubit.get_last_id('volume')
    cubit.silent_cmd(f"block {bid} add volume {new_vid}")
   status = cubit.silent_cmd(f"block {bid} remove hex all")
   t1 = time.perf_counter()
   print(f"Time to create volumes for hexes in block {bid}: {t1 - t0} seconds")

## Script body
boundary_cube(vid,mesh_size,layers)

for i in range(len(cube_vids)):
 t0 = time.perf_counter()
 vol_hexes_in_body(cube_vids[i], vid, i+1)
 t1 = time.perf_counter()
 print(f"Time to search for hexes in layer {i+1}: {t1 - t0} seconds")

cubit.cmd(f"graphics off")
create_vol_from_hexes()
cubit.silent_cmd(f"delete volume {list_to_str(cube_vids)}")

block_ids = cubit.parse_cubit_list("block","all")
for i in range(len(block_ids)-1):
 print(f"merge volumes in blocks {block_ids[i]} and {block_ids[i+1]}")
 status = cubit.cmd(f"merge surface all in vol all in block {block_ids[i+1]} {block_ids[i]}")

for i in range(len(block_ids)):
 print(f"mesh volumes in block {block_ids[i]}") 
 status = cubit.silent_cmd(f"vol all in block {block_ids[i]} size {mesh_size}")
 status = cubit.silent_cmd(f"vol all in block {block_ids[i]} scheme map")
 status = cubit.cmd(f"mesh vol all in block {block_ids[i]}")
print("finished preparing layers")
cubit.cmd(f"graphics on")

#!cubit
#draw vol all in block all
draw block all
#draw vol 1 add


